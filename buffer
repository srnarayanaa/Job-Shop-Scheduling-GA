import random
import numpy as np
import math

def DecodeChromosomes(nb_jobs, nb_machines, nb_op, OS, MS, op_times):
    job_start_time = [0] * nb_jobs   # the time when you can start a new job from a specific category
    machine_start_time = [0] * nb_machines # the time when a machine becomes available
    current_op = [0] * nb_jobs # the current opperation for each job
    sol = [[]] * nb_machines
    lately = 0
    #print('Sol', sol)

    for n_job in OS:
        job = n_job - 1
        op = current_op[job]
        
        #todo each job may have different number of operations
        ms_pos = nb_op * job + op
        machine = MS[ms_pos] - 1
        time = max(job_start_time[job], machine_start_time[machine])
        j_t = op_times[nb_op * job + op][machine]

        for i in range(machine_start_time[machine], time):
            sol[machine] = sol[machine] + [0]

        #todo must also check available slots 
        # k > job_start_time[job] k < machine_start_time[machine]
        # sol[k][machine] == [0], ... sol[k + j_t - 1][machine] == [0]
            
            
        for i in range(time, time + j_t):
            sol[machine] = sol[machine] + ['J{}'.format((job + 1) * 10 + current_op[job] + 1)]

        """
        print("Op:", op + 1, "Job:", job + 1, "Machine:", machine + 1)
        print(sol[0])
        print(sol[1])
        print(sol[2])
        print("*******")
        """

        machine_start_time[machine] = len(sol[machine])
        job_start_time[job] = len(sol[machine])
        current_op[job] += 1

    for machine in range(nb_machines):
        lately = max(lately, len(sol[machine]))

    return (lately, sol)

def OS_Crossover(OS_P1, OS_P2):
    n = len(OS_P1)
    cross_boundary = n // 2 - 1

    OS_C1 = [0] * n
    OS_C2 = [0] * n

    for i in range(n):
        if(OS_P1[i] < cross_boundary):
            OS_C1[i] = OS_P1[i]

        if (OS_P2[i]  < cross_boundary):
            OS_C2[i] = OS_P2[i]

    index = 0
    for i in range(n):
        if(OS_P2[i] >= cross_boundary):
            while OS_C1[index] != 0:
                index += 1
            OS_C1[index] = OS_P2[i]

    index = 0
    for i in range(n):
        if (OS_P1[i] >= cross_boundary):
            while OS_C2[index] != 0:
                index += 1
            OS_C2[index] = OS_P1[i]

    return OS_C1, OS_C2


def MS_Crossover(MS_P1, MS_P2):
    n = len(MS_P1)
    cross_boundary = n // 2

    MS_C1 = [0] * n
    MS_C2 = [0] * n

    for i in range(n):
        if i < cross_boundary:
            MS_C1[i] = MS_P1[i]
            MS_C2[i] = MS_P2[i]
        else:
            MS_C1[i] = MS_P2[i]
            MS_C2[i] = MS_P1[i]

    return MS_C1, MS_C2


def OS_Mutation(OS_c, pos):
    OS = OS_c.copy()
    n = len(OS)

    found = pos
    while found == pos or OS[pos] == OS[found]:
        found = random.randrange(n)

    OS[pos], OS[found] = OS[found], OS[pos]
    return OS

def MS_Mutation(MS_c, pos, OS):
    MS = MS_c.copy()
    n = len(MS)

    found = pos
    while found == pos or OS[pos] == OS[found]:
        found = random.randrange(n)

    MS[pos], MS[found] = MS[found], MS[pos]
    return MS


def genetic_algorithm():
    vex_more = []
    vex = []
    population_length = 25
    ephocs = 1000
    cross_rate = 20
    mutation_rate = 2
    op_times = [[6, 7, 2, 3, 9],
                [9, 4, 6, 13, 5],
                [6, 8, 8, 4, 9],
                [5, 2, 5, 7, 8],
                [2, 6, 7, 2, 9],
                [7, 5, 2, 9, 2],
                [3, 4, 4, 3, 9],
                [4, 7, 2, 5, 9],
                [4, 6, 3, 2, 8],
                [11, 7, 6, 5, 9],
                [10, 7, 5, 6, 5],
                [3, 7, 5, 6, 9]]
    n_jobs = 4
    n_machines = 5
    n_op = 3

    chroms = []

    print("\n\n\nStarting to populate the first epoch: \n****************************")
    for i in range(population_length):
        OS = []
        for i in range(n_jobs):
            OS = OS + [i + 1] * n_op
        random.shuffle(OS)

        #print('X ', OS)

        MS = []
        
        #todo each operation has a different list of available machines
        # op_time = [[5,math.inf, 7],[math.inf, 3, 4], ... ]
        # o_1_1 available machines 1 and 3, o_1_2 available machines 2 and 3
        for i in range(n_jobs * n_op):
            nr = random.randrange(3) + 1
            MS = MS + [nr]

        #print((OS,MS))
        chroms.append((OS,MS))

    #print('C :', chroms)

    minTime = 1000000
    best_gene = ()

    for ephoc in range(ephocs):
        #print("Ephoc {}:".format(ephoc + 1))


        """ Roulete wheel selection """

        total_time = 0.0
        interval = [0]

        for (OS, MS) in chroms: # compute total time
            time, _ = DecodeChromosomes(n_jobs, n_machines, n_op, OS, MS, op_times)
            time = 1 / time
            total_time += time

        for (OS, MS) in chroms: # set intervals
            time, _ = DecodeChromosomes(n_jobs, n_machines, n_op, OS, MS, op_times)
            time = 1 / time
            prob = time / total_time
            interval = interval + [interval[-1] + prob]
            #print(interval[-1])

        #### Selection
        cnt = 0

        selected = []
        for i in range(population_length):
            nr = random.uniform(0,1)

            for i in range(len(interval) - 1):
                if interval[i] < nr and nr < interval[i + 1]:
                    break

            selected.append(i)

        #print('Selected', selected)

        prev = 0
        paired = 0
        crossed = []

        for i in range(population_length):
            nr = random.randrange(100)

            if nr < cross_rate:
                paired ^= 1

                if(paired == 0):
                    OS1, MS1 = chroms[selected[prev]]
                    OS2, MS2 = chroms[selected[i]]

                    OS_C1, OS_C2 = OS_Crossover(OS1, OS2)
                    MS_C1, MS_C2 = MS_Crossover(MS1, MS2)

                    crossed.append((OS_C1, MS_C1))
                    crossed.append((OS_C2, MS_C2))

                prev = i

            else:
                crossed.append(chroms[selected[i]])

        if paired == 1:
            crossed.append(chroms[selected[prev]])

        print('Crossed : ', crossed)

        mutated = []

        for i in range(population_length):
            OS, MS = crossed[i]

            OS_nr = random.randrange(100)
            MS_nr = random.randrange(100)

            if(OS_nr < mutation_rate):
                OS_pos = random.randrange(len(OS))
                OS = OS_Mutation(OS, OS_pos)

            if (MS_nr < mutation_rate):
                MS_pos = random.randrange(len(MS))
                MS = MS_Mutation(MS, MS_pos, OS)

            mutated.append((OS,MS))

        chroms = mutated
        #print(np.shape(chroms))


        ep_min_time = 10000000000000
        best_sol = ()

        for i in range(population_length):
            OS, MS = chroms[i]
            time, _ = DecodeChromosomes(n_jobs, n_machines, n_op, OS, MS, op_times)
            if time < ep_min_time:
                ep_min_time = time
                best_sol = (OS, MS)

        OS, MS = best_sol
        time , rez = DecodeChromosomes(n_jobs, n_machines, n_op, OS, MS, op_times)
        vex_more.append(rez[0])
        vex.append(time)
        print()
        return vex, OS, MS

ans, OS, MS = genetic_algorithm()
print(min(ans), OS, MS)
